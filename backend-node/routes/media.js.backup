import express from 'express';
import multer from 'multer';
import path from 'path';
import { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getPool, sql } from '../config/database.js';
import { authenticateAdmin } from './admin.js';
import { v4 as uuidv4 } from 'uuid';

const router = express.Router();

// Initialize S3 Client (uses IAM role credentials from EC2)
const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'ap-south-1'
});

// Multer configuration (memory storage for S3 upload)
const storage = multer.memoryStorage();

const fileFilter = (req, file, cb) => {
  // Accept all common image and video formats
  const allowedTypes = [
    // Images
    'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/bmp', 'image/svg+xml',
    // Videos
    'video/mp4', 'video/webm', 'video/quicktime', 'video/x-msvideo', 'video/avi',
    'video/mpeg', 'video/ogg', 'video/3gpp', 'video/x-flv', 'video/x-matroska'
  ];

  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only images and videos are allowed.'), false);
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024 * 1024 // 5GB max per file (effectively unlimited for most use cases)
  }
});

// Helper function to upload to S3
const uploadToS3 = async (file, filename) => {
  const params = {
    Bucket: process.env.S3_BUCKET,
    Key: `media/${filename}`,
    Body: file.buffer,
    ContentType: file.mimetype,
  };

  await s3Client.send(new PutObjectCommand(params));

  // Return CloudFront URL
  return `https://${process.env.CLOUDFRONT_DOMAIN}/media/${filename}`;
};

// Helper function to delete from S3
const deleteFromS3 = async (filename) => {
  const params = {
    Bucket: process.env.S3_BUCKET,
    Key: `media/${filename}`,
  };

  await s3Client.send(new DeleteObjectCommand(params));
};

// Upload single file
router.post('/upload', authenticateAdmin, upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: 'No file uploaded' });
  }

  try {
    const pool = getPool();
    const mediaId = uuidv4();
    const { title, description, category } = req.body;

    // Generate unique filename
    const filename = `${Date.now()}-${uuidv4()}${path.extname(req.file.originalname)}`;

    // Upload to S3
    const url = await uploadToS3(req.file, filename);

    // Save metadata to database
    await pool.request()
      .input('id', sql.NVarChar, mediaId)
      .input('filename', sql.NVarChar, filename)
      .input('original_name', sql.NVarChar, req.file.originalname)
      .input('mimetype', sql.NVarChar, req.file.mimetype)
      .input('size', sql.BigInt, req.file.size)
      .input('path', sql.NVarChar, url)
      .input('title', sql.NVarChar, title || null)
      .input('description', sql.NVarChar, description || null)
      .input('category', sql.NVarChar, category || 'general')
      .input('uploaded_by', sql.NVarChar, req.admin.id)
      .input('created_at', sql.DateTime, new Date())
      .query(`
        INSERT INTO media (id, filename, original_name, mimetype, size, path, title, description, category, uploaded_by, created_at)
        VALUES (@id, @filename, @original_name, @mimetype, @size, @path, @title, @description, @category, @uploaded_by, @created_at)
      `);

    return res.status(201).json({
      message: 'File uploaded successfully',
      media: {
        id: mediaId,
        filename: filename,
        originalName: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size,
        url: url
      }
    });
  } catch (err) {
    console.error('Upload error:', err);
    return res.status(500).json({ message: 'Upload failed', error: err.message });
  }
});

// Upload multiple files (no limit on count)
router.post('/upload-multiple', authenticateAdmin, upload.array('files', 100), async (req, res) => {
  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ message: 'No files uploaded' });
  }

  try {
    const pool = getPool();
    const { category } = req.body;
    const uploadedMedia = [];

    for (const file of req.files) {
      const mediaId = uuidv4();
      const filename = `${Date.now()}-${uuidv4()}${path.extname(file.originalname)}`;

      // Upload to S3
      const url = await uploadToS3(file, filename);

      // Save to database
      await pool.request()
        .input('id', sql.NVarChar, mediaId)
        .input('filename', sql.NVarChar, filename)
        .input('original_name', sql.NVarChar, file.originalname)
        .input('mimetype', sql.NVarChar, file.mimetype)
        .input('size', sql.BigInt, file.size)
        .input('path', sql.NVarChar, url)
        .input('category', sql.NVarChar, category || 'general')
        .input('uploaded_by', sql.NVarChar, req.admin.id)
        .input('created_at', sql.DateTime, new Date())
        .query(`
          INSERT INTO media (id, filename, original_name, mimetype, size, path, title, description, category, uploaded_by, created_at)
          VALUES (@id, @filename, @original_name, @mimetype, @size, @path, NULL, NULL, @category, @uploaded_by, @created_at)
        `);

      uploadedMedia.push({
        id: mediaId,
        filename: filename,
        originalName: file.originalname,
        url: url
      });
    }

    return res.status(201).json({
      message: `${uploadedMedia.length} files uploaded successfully`,
      media: uploadedMedia
    });
  } catch (err) {
    console.error('Upload multiple error:', err);
    return res.status(500).json({ message: 'Upload failed', error: err.message });
  }
});

// Get all media (public endpoint - no auth required for viewing)
router.get('/', async (req, res) => {
  try {
    const pool = getPool();
    const { category } = req.query;

    let result;
    if (category) {
      result = await pool.request()
        .input('category', sql.NVarChar, category)
        .query('SELECT * FROM media WHERE category = @category ORDER BY created_at DESC');
    } else {
      result = await pool.request()
        .query('SELECT * FROM media ORDER BY created_at DESC');
    }

    // Map path to url for frontend compatibility
    const mediaWithUrls = result.recordset.map(media => ({
      ...media,
      url: media.path
    }));

    return res.status(200).json(mediaWithUrls);
  } catch (err) {
    console.error('Get media error:', err);
    return res.status(500).json({ message: 'Internal Server Error', error: err.message });
  }
});

// Get single media
router.get('/:id', async (req, res) => {
  try {
    const pool = getPool();

    const result = await pool.request()
      .input('id', sql.NVarChar, req.params.id)
      .query('SELECT * FROM media WHERE id = @id');

    if (result.recordset.length === 0) {
      return res.status(404).json({ message: 'Media not found' });
    }

    const media = result.recordset[0];
    return res.status(200).json({
      ...media,
      url: media.path
    });
  } catch (err) {
    console.error('Get media error:', err);
    return res.status(500).json({ message: 'Internal Server Error', error: err.message });
  }
});

// Delete media
router.delete('/:id', authenticateAdmin, async (req, res) => {
  try {
    const pool = getPool();

    const result = await pool.request()
      .input('id', sql.NVarChar, req.params.id)
      .query('SELECT * FROM media WHERE id = @id');

    if (result.recordset.length === 0) {
      return res.status(404).json({ message: 'Media not found' });
    }

    const media = result.recordset[0];

    // Delete from S3
    try {
      await deleteFromS3(media.filename);
    } catch (s3Error) {
      console.error('S3 delete error:', s3Error);
      // Continue even if S3 delete fails
    }

    // Delete from database
    await pool.request()
      .input('id', sql.NVarChar, req.params.id)
      .query('DELETE FROM media WHERE id = @id');

    return res.status(200).json({ message: 'Media deleted successfully' });
  } catch (err) {
    console.error('Delete media error:', err);
    return res.status(500).json({ message: 'Internal Server Error', error: err.message });
  }
});

export default router;
